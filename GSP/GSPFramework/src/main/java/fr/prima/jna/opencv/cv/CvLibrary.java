package fr.prima.jna.opencv.cv;
/**
 * JNA Wrapper for library <b>cv</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a>, <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface CvLibrary extends com.sun.jna.Library {
	public static final java.lang.String JNA_LIBRARY_NAME = com.ochafik.lang.jnaerator.runtime.LibraryExtractor.getLibraryPath("cv", true, fr.prima.jna.opencv.cv.CvLibrary.class);
	public static final com.sun.jna.NativeLibrary JNA_NATIVE_LIB = com.sun.jna.NativeLibrary.getInstance(fr.prima.jna.opencv.cv.CvLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final fr.prima.jna.opencv.cv.CvLibrary INSTANCE = (fr.prima.jna.opencv.cv.CvLibrary)com.sun.jna.Native.loadLibrary(fr.prima.jna.opencv.cv.CvLibrary.JNA_LIBRARY_NAME, fr.prima.jna.opencv.cv.CvLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/// <i>native declaration : cv.h</i>
	public static final int CV_BLUR_NO_SCALE = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BLUR = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_GAUSSIAN = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MEDIAN = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BILATERAL = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_INPAINT_NS = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_INPAINT_TELEA = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_SCHARR = -1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MAX_SOBEL_KSIZE = 7;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2BGRA = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGRA2BGR = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2RGBA = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGBA2BGR = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2RGB = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGRA2RGBA = 5;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2GRAY = 6;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2GRAY = 7;
	/// <i>native declaration : cv.h</i>
	public static final int CV_GRAY2BGR = 8;
	/// <i>native declaration : cv.h</i>
	public static final int CV_GRAY2BGRA = 9;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGRA2GRAY = 10;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGBA2GRAY = 11;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2BGR565 = 12;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2BGR565 = 13;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5652BGR = 14;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5652RGB = 15;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGRA2BGR565 = 16;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGBA2BGR565 = 17;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5652BGRA = 18;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5652RGBA = 19;
	/// <i>native declaration : cv.h</i>
	public static final int CV_GRAY2BGR565 = 20;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5652GRAY = 21;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2BGR555 = 22;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2BGR555 = 23;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5552BGR = 24;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5552RGB = 25;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGRA2BGR555 = 26;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGBA2BGR555 = 27;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5552BGRA = 28;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5552RGBA = 29;
	/// <i>native declaration : cv.h</i>
	public static final int CV_GRAY2BGR555 = 30;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR5552GRAY = 31;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2XYZ = 32;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2XYZ = 33;
	/// <i>native declaration : cv.h</i>
	public static final int CV_XYZ2BGR = 34;
	/// <i>native declaration : cv.h</i>
	public static final int CV_XYZ2RGB = 35;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2YCrCb = 36;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2YCrCb = 37;
	/// <i>native declaration : cv.h</i>
	public static final int CV_YCrCb2BGR = 38;
	/// <i>native declaration : cv.h</i>
	public static final int CV_YCrCb2RGB = 39;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2HSV = 40;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2HSV = 41;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2Lab = 44;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2Lab = 45;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerBG2BGR = 46;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerGB2BGR = 47;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerRG2BGR = 48;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerGR2BGR = 49;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2Luv = 50;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2Luv = 51;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGR2HLS = 52;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2HLS = 53;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HSV2BGR = 54;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HSV2RGB = 55;
	/// <i>native declaration : cv.h</i>
	public static final int CV_Lab2BGR = 56;
	/// <i>native declaration : cv.h</i>
	public static final int CV_Lab2RGB = 57;
	/// <i>native declaration : cv.h</i>
	public static final int CV_Luv2BGR = 58;
	/// <i>native declaration : cv.h</i>
	public static final int CV_Luv2RGB = 59;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HLS2BGR = 60;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HLS2RGB = 61;
	/// <i>native declaration : cv.h</i>
	public static final int CV_COLORCVT_MAX = 100;
	/// <i>native declaration : cv.h</i>
	public static final int CV_INTER_NN = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_INTER_LINEAR = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_INTER_CUBIC = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_INTER_AREA = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_WARP_FILL_OUTLIERS = 8;
	/// <i>native declaration : cv.h</i>
	public static final int CV_WARP_INVERSE_MAP = 16;
	/// <i>native declaration : cv.h</i>
	public static final int CV_SHAPE_RECT = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_SHAPE_CROSS = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_SHAPE_ELLIPSE = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_SHAPE_CUSTOM = 100;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MOP_OPEN = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MOP_CLOSE = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MOP_GRADIENT = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MOP_TOPHAT = 5;
	/// <i>native declaration : cv.h</i>
	public static final int CV_MOP_BLACKHAT = 6;
	/// <i>native declaration : cv.h</i>
	public static final int CV_TM_SQDIFF = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_TM_SQDIFF_NORMED = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_TM_CCORR = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_TM_CCORR_NORMED = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_TM_CCOEFF = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_TM_CCOEFF_NORMED = 5;
	/// <i>native declaration : cv.h</i>
	public static final int CV_LKFLOW_PYR_A_READY = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_LKFLOW_PYR_B_READY = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_LKFLOW_INITIAL_GUESSES = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_POLY_APPROX_DP = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_DOMINANT_IPAN = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CONTOURS_MATCH_I1 = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CONTOURS_MATCH_I2 = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CONTOURS_MATCH_I3 = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CONTOUR_TREES_MATCH_I1 = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CLOCKWISE = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_COUNTER_CLOCKWISE = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_COMP_CORREL = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_COMP_CHISQR = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_COMP_INTERSECT = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_COMP_BHATTACHARYYA = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_VALUE = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_ARRAY = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_DIST_MASK_3 = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_DIST_MASK_5 = 5;
	/// <i>native declaration : cv.h</i>
	public static final int CV_DIST_MASK_PRECISE = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_BINARY = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_BINARY_INV = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_TRUNC = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_TOZERO = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_TOZERO_INV = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_MASK = 7;
	/// <i>native declaration : cv.h</i>
	public static final int CV_THRESH_OTSU = 8;
	/// <i>native declaration : cv.h</i>
	public static final int CV_ADAPTIVE_THRESH_MEAN_C = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_ADAPTIVE_THRESH_GAUSSIAN_C = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FLOODFILL_FIXED_RANGE = (1 << 16);
	/// <i>native declaration : cv.h</i>
	public static final int CV_FLOODFILL_MASK_ONLY = (1 << 17);
	/// <i>native declaration : cv.h</i>
	public static final int CV_CANNY_L2_GRADIENT = (1 << 31);
	/// <i>native declaration : cv.h</i>
	public static final int CV_HOUGH_STANDARD = 0;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HOUGH_PROBABILISTIC = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HOUGH_MULTI_SCALE = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HOUGH_GRADIENT = 3;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HAAR_DO_CANNY_PRUNING = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_HAAR_SCALE_IMAGE = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_USE_INTRINSIC_GUESS = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_FIX_ASPECT_RATIO = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_FIX_PRINCIPAL_POINT = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_ZERO_TANGENT_DIST = 8;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_CB_ADAPTIVE_THRESH = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_CB_NORMALIZE_IMAGE = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_CALIB_CB_FILTER_QUADS = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FM_7POINT = 1;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FM_8POINT = 2;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FM_LMEDS_ONLY = 4;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FM_RANSAC_ONLY = 8;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGBA2BGRA = fr.prima.jna.opencv.cv.CvLibrary.CV_BGRA2RGBA;
	/// <i>native declaration : cv.h</i>
	public static final int CV_GRAY2RGBA = fr.prima.jna.opencv.cv.CvLibrary.CV_GRAY2BGRA;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerGR2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_BayerGB2BGR;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerBG2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_BayerRG2BGR;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FM_LMEDS = (fr.prima.jna.opencv.cv.CvLibrary.CV_FM_LMEDS_ONLY + fr.prima.jna.opencv.cv.CvLibrary.CV_FM_8POINT);
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2RGBA = fr.prima.jna.opencv.cv.CvLibrary.CV_BGR2BGRA;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGBA2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_BGRA2BGR;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BGRA2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_RGBA2BGR;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerRG2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_BayerBG2BGR;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2BGR = fr.prima.jna.opencv.cv.CvLibrary.CV_BGR2RGB;
	/// <i>native declaration : cv.h</i>
	public static final int CV_FM_RANSAC = (fr.prima.jna.opencv.cv.CvLibrary.CV_FM_RANSAC_ONLY + fr.prima.jna.opencv.cv.CvLibrary.CV_FM_8POINT);
	/// <i>native declaration : cv.h</i>
	public static final int CV_GRAY2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_GRAY2BGR;
	/// <i>native declaration : cv.h</i>
	public static final int CV_RGB2BGRA = fr.prima.jna.opencv.cv.CvLibrary.CV_BGR2RGBA;
	/// <i>native declaration : cv.h</i>
	public static final int CV_BayerGB2RGB = fr.prima.jna.opencv.cv.CvLibrary.CV_BayerGR2BGR;
	/**
	 * Copies source 2D array inside of the larger destination array and<br>
	 * makes a border of the specified type (IPL_BORDER_*) around the copied area.<br>
	 * Original signature : <code>void cvCopyMakeBorder(const CvArr*, CvArr*, CvPoint, int, CvScalar)</code><br>
	 * <i>native declaration : cv.h:64</i>
	 */
	void cvCopyMakeBorder(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue offset, int bordertype, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue value);
	/**
	 * Smoothes array (removes noise)<br>
	 * Original signature : <code>void cvSmooth(const CvArr*, CvArr*, int, int, int, double, double)</code><br>
	 * <i>native declaration : cv.h:74</i>
	 */
	void cvSmooth(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int smoothtype, int param1, int param2, double param3, double param4);
	/**
	 * Convolves the image with the kernel<br>
	 * Original signature : <code>void cvFilter2D(const CvArr*, CvArr*, const CvMat*, CvPoint)</code><br>
	 * <i>native declaration : cv.h:82</i>
	 */
	void cvFilter2D(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvMat kernel, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue anchor);
	/**
	 * Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y)<br>
	 * Original signature : <code>void cvIntegral(const CvArr*, CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:86</i>
	 */
	void cvIntegral(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr sum, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr sqsum, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr tilted_sum);
	/**
	 * Smoothes the input image with gaussian kernel and then down-samples it.<br>
	 * dst_width = floor(src_width/2)[+1],<br>
	 * dst_height = floor(src_height/2)[+1]<br>
	 * Original signature : <code>void cvPyrDown(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:95</i>
	 */
	void cvPyrDown(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int filter);
	/**
	 * Up-samples image and smoothes the result with gaussian kernel.<br>
	 * dst_width = src_width*2,<br>
	 * dst_height = src_height*2<br>
	 * Original signature : <code>void cvPyrUp(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:103</i>
	 */
	void cvPyrUp(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int filter);
	/**
	 * Splits color or grayscale image into multiple connected components<br>
	 * of nearly the same color/brightness using modification of Burt algorithm.<br>
	 * comp with contain a pointer to sequence (CvSeq)<br>
	 * of connected components (CvConnectedComp)<br>
	 * Original signature : <code>void cvPyrSegmentation(IplImage*, IplImage*, CvMemStorage*, CvSeq**, int, double, double)</code><br>
	 * <i>native declaration : cv.h:118</i><br>
	 * @deprecated use the safer method {@link #cvPyrSegmentation(fr.prima.jna.opencv.cxtypes.IplImage, fr.prima.jna.opencv.cxtypes.IplImage, fr.prima.jna.opencv.cxtypes.CvMemStorage, fr.prima.jna.opencv.cxtypes.CvSeq.ByReference[], int, double, double)} instead
	 */
	@java.lang.Deprecated
	void cvPyrSegmentation(fr.prima.jna.opencv.cxtypes.IplImage src, fr.prima.jna.opencv.cxtypes.IplImage dst, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, com.sun.jna.ptr.PointerByReference comp, int level, double threshold1, double threshold2);
	/**
	 * Splits color or grayscale image into multiple connected components<br>
	 * of nearly the same color/brightness using modification of Burt algorithm.<br>
	 * comp with contain a pointer to sequence (CvSeq)<br>
	 * of connected components (CvConnectedComp)<br>
	 * Original signature : <code>void cvPyrSegmentation(IplImage*, IplImage*, CvMemStorage*, CvSeq**, int, double, double)</code><br>
	 * <i>native declaration : cv.h:118</i>
	 */
	void cvPyrSegmentation(fr.prima.jna.opencv.cxtypes.IplImage src, fr.prima.jna.opencv.cxtypes.IplImage dst, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, fr.prima.jna.opencv.cxtypes.CvSeq.ByReference comp[], int level, double threshold1, double threshold2);
	/**
	 * Filters image using meanshift algorithm<br>
	 * Original signature : <code>void cvPyrMeanShiftFiltering(const CvArr*, CvArr*, double, double, int, CvTermCriteria)</code><br>
	 * <i>native declaration : cv.h:124</i>
	 */
	void cvPyrMeanShiftFiltering(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, double sp, double sr, int max_level, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue termcrit);
	/**
	 * Segments image using seed "markers"<br>
	 * Original signature : <code>void cvWatershed(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:129</i>
	 */
	void cvWatershed(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr markers);
	/**
	 * Inpaints the selected region in the image<br>
	 * Original signature : <code>void cvInpaint(const CvArr*, const CvArr*, CvArr*, double, int)</code><br>
	 * <i>native declaration : cv.h:135</i>
	 */
	void cvInpaint(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr inpaint_mask, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, double inpaintRange, int flags);
	/**
	 * Calculates an image derivative using generalized Sobel<br>
	 * (aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.<br>
	 * Scharr can be used only for the first dx or dy derivative<br>
	 * Original signature : <code>void cvSobel(const CvArr*, CvArr*, int, int, int)</code><br>
	 * <i>native declaration : cv.h:144</i>
	 */
	void cvSobel(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int xorder, int yorder, int aperture_size);
	/**
	 * Calculates the image Laplacian: (d2/dx + d2/dy)I<br>
	 * Original signature : <code>void cvLaplace(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:149</i>
	 */
	void cvLaplace(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int aperture_size);
	/**
	 * Converts input array pixels from one color space to another<br>
	 * Original signature : <code>void cvCvtColor(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:248</i>
	 */
	void cvCvtColor(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int code);
	/**
	 * Resizes image (input array is resized to fit the destination array)<br>
	 * Original signature : <code>void cvResize(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:259</i>
	 */
	void cvResize(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int interpolation);
	/**
	 * Warps image with affine transform<br>
	 * Original signature : <code>void cvWarpAffine(const CvArr*, CvArr*, const CvMat*, int, CvScalar)</code><br>
	 * <i>native declaration : cv.h:263</i>
	 */
	void cvWarpAffine(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvMat map_matrix, int flags, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue fillval);
	/**
	 * Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)<br>
	 * Original signature : <code>CvMat* cvGetAffineTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:268</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvMat cvGetAffineTransform(fr.prima.jna.opencv.cxtypes.CvPoint2D32f src, fr.prima.jna.opencv.cxtypes.CvPoint2D32f dst, fr.prima.jna.opencv.cxtypes.CvMat map_matrix);
	/**
	 * Computes rotation_matrix matrix<br>
	 * Original signature : <code>CvMat* cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat*)</code><br>
	 * <i>native declaration : cv.h:273</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvMat cv2DRotationMatrix(fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue center, double angle, double scale, fr.prima.jna.opencv.cxtypes.CvMat map_matrix);
	/**
	 * Warps image with perspective (projective) transform<br>
	 * Original signature : <code>void cvWarpPerspective(const CvArr*, CvArr*, const CvMat*, int, CvScalar)</code><br>
	 * <i>native declaration : cv.h:277</i>
	 */
	void cvWarpPerspective(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvMat map_matrix, int flags, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue fillval);
	/**
	 * Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)<br>
	 * Original signature : <code>CvMat* cvGetPerspectiveTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:282</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvMat cvGetPerspectiveTransform(fr.prima.jna.opencv.cxtypes.CvPoint2D32f src, fr.prima.jna.opencv.cxtypes.CvPoint2D32f dst, fr.prima.jna.opencv.cxtypes.CvMat map_matrix);
	/**
	 * Performs generic geometric transformation using the specified coordinate maps<br>
	 * Original signature : <code>void cvRemap(const CvArr*, CvArr*, const CvArr*, const CvArr*, int, CvScalar)</code><br>
	 * <i>native declaration : cv.h:287</i>
	 */
	void cvRemap(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mapx, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mapy, int flags, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue fillval);
	/**
	 * Performs forward or inverse log-polar image transform<br>
	 * Original signature : <code>void cvLogPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)</code><br>
	 * <i>native declaration : cv.h:293</i>
	 */
	void cvLogPolar(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue center, double M, int flags);
	/**
	 * creates structuring element used for morphological operations<br>
	 * Original signature : <code>IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)</code><br>
	 * <i>native declaration : cv.h:303</i><br>
	 * @deprecated use the safer methods {@link #cvCreateStructuringElementEx(int, int, int, int, int, java.nio.IntBuffer)} and {@link #cvCreateStructuringElementEx(int, int, int, int, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@java.lang.Deprecated
	fr.prima.jna.opencv.cxtypes.IplConvKernel cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, com.sun.jna.ptr.IntByReference values);
	/**
	 * creates structuring element used for morphological operations<br>
	 * Original signature : <code>IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)</code><br>
	 * <i>native declaration : cv.h:303</i>
	 */
	fr.prima.jna.opencv.cxtypes.IplConvKernel cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, java.nio.IntBuffer values);
	/**
	 * releases structuring element<br>
	 * Original signature : <code>void cvReleaseStructuringElement(IplConvKernel**)</code><br>
	 * <i>native declaration : cv.h:308</i><br>
	 * @deprecated use the safer method {@link #cvReleaseStructuringElement(fr.prima.jna.opencv.cxtypes.IplConvKernel.ByReference[])} instead
	 */
	@java.lang.Deprecated
	void cvReleaseStructuringElement(com.sun.jna.ptr.PointerByReference element);
	/**
	 * releases structuring element<br>
	 * Original signature : <code>void cvReleaseStructuringElement(IplConvKernel**)</code><br>
	 * <i>native declaration : cv.h:308</i>
	 */
	void cvReleaseStructuringElement(fr.prima.jna.opencv.cxtypes.IplConvKernel.ByReference element[]);
	/**
	 * erodes input image (applies minimum filter) one or more times.<br>
	 * If element pointer is NULL, 3x3 rectangular element is used<br>
	 * Original signature : <code>void cvErode(const CvArr*, CvArr*, IplConvKernel*, int)</code><br>
	 * <i>native declaration : cv.h:312</i>
	 */
	void cvErode(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.IplConvKernel element, int iterations);
	/**
	 * dilates input image (applies maximum filter) one or more times.<br>
	 * If element pointer is NULL, 3x3 rectangular element is used<br>
	 * Original signature : <code>void cvDilate(const CvArr*, CvArr*, IplConvKernel*, int)</code><br>
	 * <i>native declaration : cv.h:318</i>
	 */
	void cvDilate(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.IplConvKernel element, int iterations);
	/**
	 * Performs complex morphological transformation<br>
	 * Original signature : <code>void cvMorphologyEx(const CvArr*, CvArr*, CvArr*, IplConvKernel*, int, int)</code><br>
	 * <i>native declaration : cv.h:329</i>
	 */
	void cvMorphologyEx(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr temp, fr.prima.jna.opencv.cxtypes.IplConvKernel element, int operation, int iterations);
	/**
	 * Calculates all spatial and central moments up to the 3rd order<br>
	 * Original signature : <code>void cvMoments(const CvArr*, CvMoments*, int)</code><br>
	 * <i>native declaration : cv.h:334</i>
	 */
	void cvMoments(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr arr, fr.prima.jna.opencv.cvtypes.CvMoments moments, int binary);
	/**
	 * Retrieve particular spatial, central or normalized central moments<br>
	 * Original signature : <code>double cvGetSpatialMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : cv.h:337</i>
	 */
	double cvGetSpatialMoment(fr.prima.jna.opencv.cvtypes.CvMoments moments, int x_order, int y_order);
	/**
	 * Original signature : <code>double cvGetCentralMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : cv.h:338</i>
	 */
	double cvGetCentralMoment(fr.prima.jna.opencv.cvtypes.CvMoments moments, int x_order, int y_order);
	/**
	 * Original signature : <code>double cvGetNormalizedCentralMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : cv.h:339</i>
	 */
	double cvGetNormalizedCentralMoment(fr.prima.jna.opencv.cvtypes.CvMoments moments, int x_order, int y_order);
	/**
	 * Calculates 7 Hu's invariants from precalculated spatial and central moments<br>
	 * Original signature : <code>void cvGetHuMoments(CvMoments*, CvHuMoments*)</code><br>
	 * <i>native declaration : cv.h:343</i>
	 */
	void cvGetHuMoments(fr.prima.jna.opencv.cvtypes.CvMoments moments, fr.prima.jna.opencv.cvtypes.CvHuMoments hu_moments);
	/**
	 * Fetches pixels that belong to the specified line segment and stores them to the buffer.<br>
	 * Returns the number of retrieved points.<br>
	 * Original signature : <code>int cvSampleLine(const CvArr*, CvPoint, CvPoint, void*, int)</code><br>
	 * <i>native declaration : cv.h:349</i>
	 */
	int cvSampleLine(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue pt1, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue pt2, com.sun.jna.Pointer buffer, int connectivity);
	/**
	 * Retrieves the rectangular image region with specified center from the input array.<br>
	 * dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2).<br>
	 * Values of pixels with fractional coordinates are retrieved using bilinear interpolation<br>
	 * Original signature : <code>void cvGetRectSubPix(const CvArr*, CvArr*, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv.h:355</i>
	 */
	void cvGetRectSubPix(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue center);
	/**
	 * Retrieves quadrangle from the input array.<br>
	 * matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)<br>
	 * ( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels<br>
	 * with fractional coordinates)<br>
	 * Original signature : <code>void cvGetQuadrangleSubPix(const CvArr*, CvArr*, const CvMat*)</code><br>
	 * <i>native declaration : cv.h:363</i>
	 */
	void cvGetQuadrangleSubPix(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvMat map_matrix);
	/**
	 * Measures similarity between template and overlapped windows in the source image<br>
	 * and fills the resultant image with the measurements<br>
	 * Original signature : <code>void cvMatchTemplate(const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:376</i>
	 */
	void cvMatchTemplate(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr templ, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr result, int method);
	/**
	 * <i>native declaration : cv.h:381</i><br>
	 * Conversion Error : CvDistanceFunction
	 */
	/**
	 * Retrieves outer and optionally inner boundaries of white (non-zero) connected<br>
	 * components in the black (zero) background<br>
	 * Original signature : <code>int cvFindContours(CvArr*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : cv.h:396</i><br>
	 * @deprecated use the safer method {@link #cvFindContours(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvMemStorage, fr.prima.jna.opencv.cxtypes.CvSeq.ByReference[], int, int, int, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue)} instead
	 */
	@java.lang.Deprecated
	int cvFindContours(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, com.sun.jna.ptr.PointerByReference first_contour, int header_size, int mode, int method, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue offset);
	/**
	 * Retrieves outer and optionally inner boundaries of white (non-zero) connected<br>
	 * components in the black (zero) background<br>
	 * Original signature : <code>int cvFindContours(CvArr*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : cv.h:396</i>
	 */
	int cvFindContours(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, fr.prima.jna.opencv.cxtypes.CvSeq.ByReference first_contour[], int header_size, int mode, int method, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue offset);
	/**
	 * Initalizes contour retrieving process.<br>
	 * Calls cvStartFindContours.<br>
	 * Calls cvFindNextContour until null pointer is returned<br>
	 * or some other condition becomes true.<br>
	 * Calls cvEndFindContours at the end.<br>
	 * Original signature : <code>CvContourScanner cvStartFindContours(CvArr*, CvMemStorage*, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : cv.h:408</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvContourScanner cvStartFindContours(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, int header_size, int mode, int method, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue offset);
	/**
	 * Retrieves next contour<br>
	 * Original signature : <code>CvSeq* cvFindNextContour(CvContourScanner)</code><br>
	 * <i>native declaration : cv.h:415</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvFindNextContour(fr.prima.jna.opencv.cv.CvLibrary.CvContourScanner scanner);
	/**
	 * Substitutes the last retrieved contour with the new one<br>
	 * (if the substitutor is null, the last retrieved contour is removed from the tree)<br>
	 * Original signature : <code>void cvSubstituteContour(CvContourScanner, CvSeq*)</code><br>
	 * <i>native declaration : cv.h:420</i>
	 */
	void cvSubstituteContour(fr.prima.jna.opencv.cv.CvLibrary.CvContourScanner scanner, fr.prima.jna.opencv.cxtypes.CvSeq new_contour);
	/**
	 * Releases contour scanner and returns pointer to the first outer contour<br>
	 * Original signature : <code>CvSeq* cvEndFindContours(CvContourScanner*)</code><br>
	 * <i>native declaration : cv.h:424</i><br>
	 * @deprecated use the safer method {@link #cvEndFindContours(fr.prima.jna.opencv.cv.CvLibrary.CvContourScanner[])} instead
	 */
	@java.lang.Deprecated
	fr.prima.jna.opencv.cxtypes.CvSeq cvEndFindContours(com.sun.jna.ptr.PointerByReference scanner);
	/**
	 * Releases contour scanner and returns pointer to the first outer contour<br>
	 * Original signature : <code>CvSeq* cvEndFindContours(CvContourScanner*)</code><br>
	 * <i>native declaration : cv.h:424</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvEndFindContours(fr.prima.jna.opencv.cv.CvLibrary.CvContourScanner scanner[]);
	/**
	 * Approximates a single Freeman chain or a tree of chains to polygonal curves<br>
	 * Original signature : <code>CvSeq* cvApproxChains(CvSeq*, CvMemStorage*, int, double, int, int)</code><br>
	 * <i>native declaration : cv.h:427</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvApproxChains(fr.prima.jna.opencv.cxtypes.CvSeq src_seq, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, int method, double parameter, int minimal_perimeter, int recursive);
	/**
	 * Initalizes Freeman chain reader.<br>
	 * The reader is used to iteratively get coordinates of all the chain points.<br>
	 * If the Freeman codes should be read as is, a simple sequence reader should be used<br>
	 * Original signature : <code>void cvStartReadChainPoints(CvChain*, CvChainPtReader*)</code><br>
	 * <i>native declaration : cv.h:437</i>
	 */
	void cvStartReadChainPoints(fr.prima.jna.opencv.cxtypes.CvChain chain, fr.prima.jna.opencv.cvtypes.CvChainPtReader reader);
	/**
	 * Retrieves the next chain point<br>
	 * Original signature : <code>CvPoint cvReadChainPoint(CvChainPtReader*)</code><br>
	 * <i>native declaration : cv.h:440</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvPoint.ByValue cvReadChainPoint(fr.prima.jna.opencv.cvtypes.CvChainPtReader reader);
	/**
	 * Calculates optical flow for 2 images using classical Lucas & Kanade algorithm<br>
	 * Original signature : <code>void cvCalcOpticalFlowLK(const CvArr*, const CvArr*, CvSize, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:450</i>
	 */
	void cvCalcOpticalFlowLK(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr, fr.prima.jna.opencv.cxtypes.CvSize.ByValue win_size, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr velx, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr vely);
	/**
	 * Calculates optical flow for 2 images using block matching algorithm<br>
	 * Original signature : <code>void cvCalcOpticalFlowBM(const CvArr*, const CvArr*, CvSize, CvSize, CvSize, int, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:454</i>
	 */
	void cvCalcOpticalFlowBM(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr, fr.prima.jna.opencv.cxtypes.CvSize.ByValue block_size, fr.prima.jna.opencv.cxtypes.CvSize.ByValue shift_size, fr.prima.jna.opencv.cxtypes.CvSize.ByValue max_range, int use_previous, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr velx, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr vely);
	/**
	 * Calculates Optical flow for 2 images using Horn & Schunck algorithm<br>
	 * Original signature : <code>void cvCalcOpticalFlowHS(const CvArr*, const CvArr*, int, CvArr*, CvArr*, double, CvTermCriteria)</code><br>
	 * <i>native declaration : cv.h:460</i>
	 */
	void cvCalcOpticalFlowHS(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr, int use_previous, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr velx, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr vely, double lambda, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria);
	/**
	 * It is Lucas & Kanade method, modified to use pyramids.<br>
	 * Also it does several iterations to get optical flow for<br>
	 * every point at every pyramid level.<br>
	 * Calculates optical flow between two images for certain set of points (i.e.<br>
	 * it is a "sparse" optical flow, which is opposite to the previous 3 methods)<br>
	 * Original signature : <code>void cvCalcOpticalFlowPyrLK(const CvArr*, const CvArr*, CvArr*, CvArr*, const CvPoint2D32f*, CvPoint2D32f*, int, CvSize, int, char*, float*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv.h:473</i><br>
	 * @deprecated use the safer methods {@link #cvCalcOpticalFlowPyrLK(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, int, fr.prima.jna.opencv.cxtypes.CvSize.ByValue, int, java.nio.ByteBuffer, java.nio.FloatBuffer, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue, int)} and {@link #cvCalcOpticalFlowPyrLK(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, int, fr.prima.jna.opencv.cxtypes.CvSize.ByValue, int, com.sun.jna.Pointer, com.sun.jna.ptr.FloatByReference, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue, int)} instead
	 */
	@java.lang.Deprecated
	void cvCalcOpticalFlowPyrLK(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev_pyr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr_pyr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f prev_features, fr.prima.jna.opencv.cxtypes.CvPoint2D32f curr_features, int count, fr.prima.jna.opencv.cxtypes.CvSize.ByValue win_size, int level, com.sun.jna.Pointer status, com.sun.jna.ptr.FloatByReference track_error, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria, int flags);
	/**
	 * It is Lucas & Kanade method, modified to use pyramids.<br>
	 * Also it does several iterations to get optical flow for<br>
	 * every point at every pyramid level.<br>
	 * Calculates optical flow between two images for certain set of points (i.e.<br>
	 * it is a "sparse" optical flow, which is opposite to the previous 3 methods)<br>
	 * Original signature : <code>void cvCalcOpticalFlowPyrLK(const CvArr*, const CvArr*, CvArr*, CvArr*, const CvPoint2D32f*, CvPoint2D32f*, int, CvSize, int, char*, float*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv.h:473</i>
	 */
	void cvCalcOpticalFlowPyrLK(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prev_pyr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr curr_pyr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f prev_features, fr.prima.jna.opencv.cxtypes.CvPoint2D32f curr_features, int count, fr.prima.jna.opencv.cxtypes.CvSize.ByValue win_size, int level, java.nio.ByteBuffer status, java.nio.FloatBuffer track_error, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria, int flags);
	/**
	 * Updates motion history image given motion silhouette<br>
	 * Original signature : <code>void cvUpdateMotionHistory(const CvArr*, CvArr*, double, double)</code><br>
	 * <i>native declaration : cv.h:510</i>
	 */
	void cvUpdateMotionHistory(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr silhouette, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mhi, double timestamp, double duration);
	/**
	 * Calculates gradient of the motion history image and fills<br>
	 * a mask indicating where the gradient is valid<br>
	 * Original signature : <code>void cvCalcMotionGradient(const CvArr*, CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : cv.h:515</i>
	 */
	void cvCalcMotionGradient(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mhi, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr orientation, double delta1, double delta2, int aperture_size);
	/**
	 * Calculates average motion direction within a selected motion region <br>
	 * (region can be selected by setting ROIs and/or by composing a valid gradient mask<br>
	 * with the region mask)<br>
	 * Original signature : <code>double cvCalcGlobalOrientation(const CvArr*, const CvArr*, const CvArr*, double, double)</code><br>
	 * <i>native declaration : cv.h:522</i>
	 */
	double cvCalcGlobalOrientation(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr orientation, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mhi, double timestamp, double duration);
	/**
	 * Splits a motion history image into a few parts corresponding to separate independent motions<br>
	 * (e.g. left hand, right hand)<br>
	 * Original signature : <code>CvSeq* cvSegmentMotion(const CvArr*, CvArr*, CvMemStorage*, double, double)</code><br>
	 * <i>native declaration : cv.h:528</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvSegmentMotion(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mhi, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr seg_mask, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, double timestamp, double seg_thresh);
	/**
	 * Adds image to accumulator<br>
	 * Original signature : <code>void cvAcc(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:535</i>
	 */
	void cvAcc(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr sum, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Adds squared image to accumulator<br>
	 * Original signature : <code>void cvSquareAcc(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:539</i>
	 */
	void cvSquareAcc(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr sqsum, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Adds a product of two images to accumulator<br>
	 * Original signature : <code>void cvMultiplyAcc(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:543</i>
	 */
	void cvMultiplyAcc(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image1, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image2, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr acc, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha<br>
	 * Original signature : <code>void cvRunningAvg(const CvArr*, CvArr*, double, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:547</i>
	 */
	void cvRunningAvg(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr acc, double alpha, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Implements CAMSHIFT algorithm - determines object position, size and orientation<br>
	 * from the object histogram back project (extension of meanshift)<br>
	 * Original signature : <code>int cvCamShift(const CvArr*, CvRect, CvTermCriteria, CvConnectedComp*, CvBox2D*)</code><br>
	 * <i>native declaration : cv.h:557</i>
	 */
	int cvCamShift(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prob_image, fr.prima.jna.opencv.cxtypes.CvRect.ByValue window, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria, fr.prima.jna.opencv.cvtypes.CvConnectedComp comp, fr.prima.jna.opencv.cxtypes.CvBox2D box);
	/**
	 * Implements MeanShift algorithm - determines object position<br>
	 * from the object histogram back project<br>
	 * Original signature : <code>int cvMeanShift(const CvArr*, CvRect, CvTermCriteria, CvConnectedComp*)</code><br>
	 * <i>native declaration : cv.h:563</i>
	 */
	int cvMeanShift(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr prob_image, fr.prima.jna.opencv.cxtypes.CvRect.ByValue window, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria, fr.prima.jna.opencv.cvtypes.CvConnectedComp comp);
	/**
	 * Creates ConDensation filter state<br>
	 * Original signature : <code>CvConDensation* cvCreateConDensation(int, int, int)</code><br>
	 * <i>native declaration : cv.h:567</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvConDensation cvCreateConDensation(int dynam_params, int measure_params, int sample_count);
	/**
	 * Releases ConDensation filter state<br>
	 * Original signature : <code>void cvReleaseConDensation(CvConDensation**)</code><br>
	 * <i>native declaration : cv.h:572</i><br>
	 * @deprecated use the safer method {@link #cvReleaseConDensation(fr.prima.jna.opencv.cv.CvLibrary.CvConDensation[])} instead
	 */
	@java.lang.Deprecated
	void cvReleaseConDensation(com.sun.jna.ptr.PointerByReference condens);
	/**
	 * Releases ConDensation filter state<br>
	 * Original signature : <code>void cvReleaseConDensation(CvConDensation**)</code><br>
	 * <i>native declaration : cv.h:572</i>
	 */
	void cvReleaseConDensation(fr.prima.jna.opencv.cv.CvLibrary.CvConDensation condens[]);
	/**
	 * Updates ConDensation filter by time (predict future state of the system)<br>
	 * Original signature : <code>void cvConDensUpdateByTime(CvConDensation*)</code><br>
	 * <i>native declaration : cv.h:575</i>
	 */
	void cvConDensUpdateByTime(fr.prima.jna.opencv.cv.CvLibrary.CvConDensation condens);
	/**
	 * Initializes ConDensation filter samples<br>
	 * Original signature : <code>void cvConDensInitSampleSet(CvConDensation*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:578</i>
	 */
	void cvConDensInitSampleSet(fr.prima.jna.opencv.cv.CvLibrary.CvConDensation condens, fr.prima.jna.opencv.cxtypes.CvMat lower_bound, fr.prima.jna.opencv.cxtypes.CvMat upper_bound);
	/**
	 * Creates Kalman filter and sets A, B, Q, R and state to some initial values<br>
	 * Original signature : <code>CvKalman* cvCreateKalman(int, int, int)</code><br>
	 * <i>native declaration : cv.h:581</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvKalman cvCreateKalman(int dynam_params, int measure_params, int control_params);
	/**
	 * Releases Kalman filter state<br>
	 * Original signature : <code>void cvReleaseKalman(CvKalman**)</code><br>
	 * <i>native declaration : cv.h:585</i><br>
	 * @deprecated use the safer method {@link #cvReleaseKalman(fr.prima.jna.opencv.cv.CvLibrary.CvKalman[])} instead
	 */
	@java.lang.Deprecated
	void cvReleaseKalman(com.sun.jna.ptr.PointerByReference kalman);
	/**
	 * Releases Kalman filter state<br>
	 * Original signature : <code>void cvReleaseKalman(CvKalman**)</code><br>
	 * <i>native declaration : cv.h:585</i>
	 */
	void cvReleaseKalman(fr.prima.jna.opencv.cv.CvLibrary.CvKalman kalman[]);
	/**
	 * Updates Kalman filter by time (predicts future state of the system)<br>
	 * Original signature : <code>CvMat* cvKalmanPredict(CvKalman*, const CvMat*)</code><br>
	 * <i>native declaration : cv.h:588</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvMat cvKalmanPredict(fr.prima.jna.opencv.cv.CvLibrary.CvKalman kalman, fr.prima.jna.opencv.cxtypes.CvMat control);
	/**
	 * Updates Kalman filter by measurement<br>
	 * (corrects state of the system and internal matrices)<br>
	 * Original signature : <code>CvMat* cvKalmanCorrect(CvKalman*, const CvMat*)</code><br>
	 * <i>native declaration : cv.h:593</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvMat cvKalmanCorrect(fr.prima.jna.opencv.cv.CvLibrary.CvKalman kalman, fr.prima.jna.opencv.cxtypes.CvMat measurement);
	/**
	 * Initializes Delaunay triangulation<br>
	 * Original signature : <code>void cvInitSubdivDelaunay2D(CvSubdiv2D*, CvRect)</code><br>
	 * <i>native declaration : cv.h:600</i>
	 */
	void cvInitSubdivDelaunay2D(fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D subdiv, fr.prima.jna.opencv.cxtypes.CvRect.ByValue rect);
	/**
	 * Creates new subdivision<br>
	 * Original signature : <code>CvSubdiv2D* cvCreateSubdiv2D(int, int, int, int, CvMemStorage*)</code><br>
	 * <i>native declaration : cv.h:603</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D cvCreateSubdiv2D(int subdiv_type, int header_size, int vtx_size, int quadedge_size, fr.prima.jna.opencv.cxtypes.CvMemStorage storage);
	/**
	 * Original signature : <code>CvSubdiv2D* cvCreateSubdivDelaunay2D(CvRect, CvMemStorage*)</code><br>
	 * <i>native declaration : cv.h:610</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D cvCreateSubdivDelaunay2D(fr.prima.jna.opencv.cxtypes.CvRect.ByValue rect, fr.prima.jna.opencv.cxtypes.CvMemStorage storage);
	/**
	 * Inserts new point to the Delaunay triangulation<br>
	 * Original signature : <code>CvSubdiv2DPoint* cvSubdivDelaunay2DInsert(CvSubdiv2D*, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv.h:621</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2DPoint cvSubdivDelaunay2DInsert(fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D subdiv, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue pt);
	/**
	 * <i>native declaration : cv.h:626</i><br>
	 * Conversion Error : CvSubdiv2DPointLocation
	 */
	/**
	 * Calculates Voronoi tesselation (i.e. coordinates of Voronoi points)<br>
	 * Original signature : <code>void cvCalcSubdivVoronoi2D(CvSubdiv2D*)</code><br>
	 * <i>native declaration : cv.h:632</i>
	 */
	void cvCalcSubdivVoronoi2D(fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D subdiv);
	/**
	 * Removes all Voronoi points from the tesselation<br>
	 * Original signature : <code>void cvClearSubdivVoronoi2D(CvSubdiv2D*)</code><br>
	 * <i>native declaration : cv.h:636</i>
	 */
	void cvClearSubdivVoronoi2D(fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D subdiv);
	/**
	 * Finds the nearest to the given point vertex in subdivision.<br>
	 * Original signature : <code>CvSubdiv2DPoint* cvFindNearestPoint2D(CvSubdiv2D*, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv.h:640</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2DPoint cvFindNearestPoint2D(fr.prima.jna.opencv.cv.CvLibrary.CvSubdiv2D subdiv, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue pt);
	/**
	 * <i>native declaration : cv.h:645</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv.h:651</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv.h:656</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv.h:661</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv.h:669</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv.h:676</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * Original signature : <code>double cvTriangleArea(CvPoint2D32f, CvPoint2D32f, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv.h:683</i>
	 */
	double cvTriangleArea(fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue a, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue b, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue c);
	/**
	 * Approximates a single polygonal curve (contour) or<br>
	 * a tree of polygonal curves (contours)<br>
	 * Original signature : <code>CvSeq* cvApproxPoly(const void*, int, CvMemStorage*, int, double, int)</code><br>
	 * <i>native declaration : cv.h:697</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvApproxPoly(com.sun.jna.Pointer src_seq, int header_size, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, int method, double parameter, int parameter2);
	/**
	 * Finds high-curvature points of the contour<br>
	 * Original signature : <code>CvSeq* cvFindDominantPoints(CvSeq*, CvMemStorage*, int, double, double, double, double)</code><br>
	 * <i>native declaration : cv.h:705</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvFindDominantPoints(fr.prima.jna.opencv.cxtypes.CvSeq contour, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, int method, double parameter1, double parameter2, double parameter3, double parameter4);
	/**
	 * Calculates perimeter of a contour or length of a part of contour<br>
	 * Original signature : <code>double cvArcLength(const void*, CvSlice, int)</code><br>
	 * <i>native declaration : cv.h:713</i>
	 */
	double cvArcLength(com.sun.jna.Pointer curve, fr.prima.jna.opencv.cxtypes.CvSlice.ByValue slice, int is_closed);
	/**
	 * Calculates contour boundning rectangle (update=1) or<br>
	 * just retrieves pre-calculated rectangle (update=0)<br>
	 * Original signature : <code>CvRect* cvBoundingRect(CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:720</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvRect cvBoundingRect(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points, int update);
	/**
	 * Calculates area of a contour or contour segment<br>
	 * Original signature : <code>double cvContourArea(const CvArr*, CvSlice)</code><br>
	 * <i>native declaration : cv.h:723</i>
	 */
	double cvContourArea(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr contour, fr.prima.jna.opencv.cxtypes.CvSlice.ByValue slice);
	/**
	 * Finds minimum area rotated rectangle bounding a set of points<br>
	 * Original signature : <code>CvBox2D cvMinAreaRect2(const CvArr*, CvMemStorage*)</code><br>
	 * <i>native declaration : cv.h:727</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvBox2D.ByValue cvMinAreaRect2(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points, fr.prima.jna.opencv.cxtypes.CvMemStorage storage);
	/**
	 * Finds minimum enclosing circle for a set of points<br>
	 * Original signature : <code>int cvMinEnclosingCircle(const CvArr*, CvPoint2D32f*, float*)</code><br>
	 * <i>native declaration : cv.h:731</i><br>
	 * @deprecated use the safer methods {@link #cvMinEnclosingCircle(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, java.nio.FloatBuffer)} and {@link #cvMinEnclosingCircle(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, com.sun.jna.ptr.FloatByReference)} instead
	 */
	@java.lang.Deprecated
	int cvMinEnclosingCircle(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points, fr.prima.jna.opencv.cxtypes.CvPoint2D32f center, com.sun.jna.ptr.FloatByReference radius);
	/**
	 * Finds minimum enclosing circle for a set of points<br>
	 * Original signature : <code>int cvMinEnclosingCircle(const CvArr*, CvPoint2D32f*, float*)</code><br>
	 * <i>native declaration : cv.h:731</i>
	 */
	int cvMinEnclosingCircle(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points, fr.prima.jna.opencv.cxtypes.CvPoint2D32f center, java.nio.FloatBuffer radius);
	/**
	 * Compares two contours by matching their moments<br>
	 * Original signature : <code>double cvMatchShapes(const void*, const void*, int, double)</code><br>
	 * <i>native declaration : cv.h:739</i>
	 */
	double cvMatchShapes(com.sun.jna.Pointer object1, com.sun.jna.Pointer object2, int method, double parameter);
	/**
	 * Builds hierarhical representation of a contour<br>
	 * Original signature : <code>CvContourTree* cvCreateContourTree(const CvSeq*, CvMemStorage*, double)</code><br>
	 * <i>native declaration : cv.h:743</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvContourTree cvCreateContourTree(fr.prima.jna.opencv.cxtypes.CvSeq contour, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, double threshold);
	/**
	 * Reconstruct (completelly or partially) contour a from contour tree<br>
	 * Original signature : <code>CvSeq* cvContourFromContourTree(const CvContourTree*, CvMemStorage*, CvTermCriteria)</code><br>
	 * <i>native declaration : cv.h:748</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvContourFromContourTree(fr.prima.jna.opencv.cv.CvLibrary.CvContourTree tree, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria);
	/**
	 * Original signature : <code>double cvMatchContourTrees(const CvContourTree*, const CvContourTree*, int, double)</code><br>
	 * <i>native declaration : cv.h:755</i>
	 */
	double cvMatchContourTrees(fr.prima.jna.opencv.cv.CvLibrary.CvContourTree tree1, fr.prima.jna.opencv.cv.CvLibrary.CvContourTree tree2, int method, double threshold);
	/**
	 * Calculates histogram of a contour<br>
	 * Original signature : <code>void cvCalcPGH(const CvSeq*, CvHistogram*)</code><br>
	 * <i>native declaration : cv.h:760</i>
	 */
	void cvCalcPGH(fr.prima.jna.opencv.cxtypes.CvSeq contour, fr.prima.jna.opencv.cxtypes.CvHistogram hist);
	/**
	 * Calculates exact convex hull of 2d point set<br>
	 * Original signature : <code>CvSeq* cvConvexHull2(const CvArr*, void*, int, int)</code><br>
	 * <i>native declaration : cv.h:766</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvConvexHull2(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr input, com.sun.jna.Pointer hull_storage, int orientation, int return_points);
	/**
	 * Checks whether the contour is convex or not (returns 1 if convex, 0 if not)<br>
	 * Original signature : <code>int cvCheckContourConvexity(const CvArr*)</code><br>
	 * <i>native declaration : cv.h:772</i>
	 */
	int cvCheckContourConvexity(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr contour);
	/**
	 * Finds convexity defects for the contour<br>
	 * Original signature : <code>CvSeq* cvConvexityDefects(const CvArr*, const CvArr*, CvMemStorage*)</code><br>
	 * <i>native declaration : cv.h:775</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvConvexityDefects(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr contour, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr convexhull, fr.prima.jna.opencv.cxtypes.CvMemStorage storage);
	/**
	 * Fits ellipse into a set of 2d points<br>
	 * Original signature : <code>CvBox2D cvFitEllipse2(const CvArr*)</code><br>
	 * <i>native declaration : cv.h:779</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvBox2D.ByValue cvFitEllipse2(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points);
	/**
	 * Finds minimum rectangle containing two given rectangles<br>
	 * Original signature : <code>CvRect cvMaxRect(const CvRect*, const CvRect*)</code><br>
	 * <i>native declaration : cv.h:782</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvRect.ByValue cvMaxRect(fr.prima.jna.opencv.cxtypes.CvRect rect1, fr.prima.jna.opencv.cxtypes.CvRect rect2);
	/**
	 * Finds coordinates of the box vertices<br>
	 * Original signature : <code>void cvBoxPoints(CvBox2D, CvPoint2D32f[4])</code><br>
	 * <i>native declaration : cv.h:785</i><br>
	 * @deprecated use the safer method {@link #cvBoxPoints(fr.prima.jna.opencv.cxtypes.CvBox2D.ByValue, fr.prima.jna.opencv.cxtypes.CvPoint2D32f[])} instead
	 */
	@java.lang.Deprecated
	void cvBoxPoints(fr.prima.jna.opencv.cxtypes.CvBox2D.ByValue box, com.sun.jna.Pointer pt);
	/**
	 * Finds coordinates of the box vertices<br>
	 * Original signature : <code>void cvBoxPoints(CvBox2D, CvPoint2D32f[4])</code><br>
	 * <i>native declaration : cv.h:785</i>
	 */
	void cvBoxPoints(fr.prima.jna.opencv.cxtypes.CvBox2D.ByValue box, fr.prima.jna.opencv.cxtypes.CvPoint2D32f pt[]);
	/**
	 * Initializes sequence header for a matrix (column or row vector) of points -<br>
	 * a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)<br>
	 * Original signature : <code>CvSeq* cvPointSeqFromMat(int, const CvArr*, CvContour*, CvSeqBlock*)</code><br>
	 * <i>native declaration : cv.h:789</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvPointSeqFromMat(int seq_kind, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mat, fr.prima.jna.opencv.cxtypes.CvContour contour_header, fr.prima.jna.opencv.cxtypes.CvSeqBlock block);
	/**
	 * Checks whether the point is inside polygon, outside, on an edge (at a vertex).<br>
	 * Returns positive, negative or zero value, correspondingly.<br>
	 * Optionally, measures a signed distance between<br>
	 * the point and the nearest polygon edge (measure_dist=1)<br>
	 * Original signature : <code>double cvPointPolygonTest(const CvArr*, CvPoint2D32f, int)</code><br>
	 * <i>native declaration : cv.h:797</i>
	 */
	double cvPointPolygonTest(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr contour, fr.prima.jna.opencv.cxtypes.CvPoint2D32f.ByValue pt, int measure_dist);
	/**
	 * Creates new histogram<br>
	 * Original signature : <code>CvHistogram* cvCreateHist(int, int*, int, float**, int)</code><br>
	 * <i>native declaration : cv.h:805</i><br>
	 * @deprecated use the safer methods {@link #cvCreateHist(int, java.nio.IntBuffer, int, com.sun.jna.ptr.PointerByReference, int)} and {@link #cvCreateHist(int, com.sun.jna.ptr.IntByReference, int, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@java.lang.Deprecated
	fr.prima.jna.opencv.cxtypes.CvHistogram cvCreateHist(int dims, com.sun.jna.ptr.IntByReference sizes, int type, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Creates new histogram<br>
	 * Original signature : <code>CvHistogram* cvCreateHist(int, int*, int, float**, int)</code><br>
	 * <i>native declaration : cv.h:805</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvHistogram cvCreateHist(int dims, java.nio.IntBuffer sizes, int type, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Assignes histogram bin ranges<br>
	 * Original signature : <code>void cvSetHistBinRanges(CvHistogram*, float**, int)</code><br>
	 * <i>native declaration : cv.h:810</i>
	 */
	void cvSetHistBinRanges(fr.prima.jna.opencv.cxtypes.CvHistogram hist, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Creates histogram header for array<br>
	 * Original signature : <code>CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)</code><br>
	 * <i>native declaration : cv.h:814</i><br>
	 * @deprecated use the safer methods {@link #cvMakeHistHeaderForArray(int, java.nio.IntBuffer, fr.prima.jna.opencv.cxtypes.CvHistogram, java.nio.FloatBuffer, com.sun.jna.ptr.PointerByReference, int)} and {@link #cvMakeHistHeaderForArray(int, com.sun.jna.ptr.IntByReference, fr.prima.jna.opencv.cxtypes.CvHistogram, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@java.lang.Deprecated
	fr.prima.jna.opencv.cxtypes.CvHistogram cvMakeHistHeaderForArray(int dims, com.sun.jna.ptr.IntByReference sizes, fr.prima.jna.opencv.cxtypes.CvHistogram hist, com.sun.jna.ptr.FloatByReference data, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Creates histogram header for array<br>
	 * Original signature : <code>CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)</code><br>
	 * <i>native declaration : cv.h:814</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvHistogram cvMakeHistHeaderForArray(int dims, java.nio.IntBuffer sizes, fr.prima.jna.opencv.cxtypes.CvHistogram hist, java.nio.FloatBuffer data, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Releases histogram<br>
	 * Original signature : <code>void cvReleaseHist(CvHistogram**)</code><br>
	 * <i>native declaration : cv.h:820</i><br>
	 * @deprecated use the safer method {@link #cvReleaseHist(fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference[])} instead
	 */
	@java.lang.Deprecated
	void cvReleaseHist(com.sun.jna.ptr.PointerByReference hist);
	/**
	 * Releases histogram<br>
	 * Original signature : <code>void cvReleaseHist(CvHistogram**)</code><br>
	 * <i>native declaration : cv.h:820</i>
	 */
	void cvReleaseHist(fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference hist[]);
	/**
	 * Clears all the histogram bins<br>
	 * Original signature : <code>void cvClearHist(CvHistogram*)</code><br>
	 * <i>native declaration : cv.h:823</i>
	 */
	void cvClearHist(fr.prima.jna.opencv.cxtypes.CvHistogram hist);
	/**
	 * Finds indices and values of minimum and maximum histogram bins<br>
	 * Original signature : <code>void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)</code><br>
	 * <i>native declaration : cv.h:826</i><br>
	 * @deprecated use the safer methods {@link #cvGetMinMaxHistValue(fr.prima.jna.opencv.cxtypes.CvHistogram, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #cvGetMinMaxHistValue(fr.prima.jna.opencv.cxtypes.CvHistogram, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@java.lang.Deprecated
	void cvGetMinMaxHistValue(fr.prima.jna.opencv.cxtypes.CvHistogram hist, com.sun.jna.ptr.FloatByReference min_value, com.sun.jna.ptr.FloatByReference max_value, com.sun.jna.ptr.IntByReference min_idx, com.sun.jna.ptr.IntByReference max_idx);
	/**
	 * Finds indices and values of minimum and maximum histogram bins<br>
	 * Original signature : <code>void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)</code><br>
	 * <i>native declaration : cv.h:826</i>
	 */
	void cvGetMinMaxHistValue(fr.prima.jna.opencv.cxtypes.CvHistogram hist, java.nio.FloatBuffer min_value, java.nio.FloatBuffer max_value, java.nio.IntBuffer min_idx, java.nio.IntBuffer max_idx);
	/**
	 * Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>.<br>
	 * After that sum of histogram bins is equal to <factor><br>
	 * Original signature : <code>void cvNormalizeHist(CvHistogram*, double)</code><br>
	 * <i>native declaration : cv.h:834</i>
	 */
	void cvNormalizeHist(fr.prima.jna.opencv.cxtypes.CvHistogram hist, double factor);
	/**
	 * Clear all histogram bins that are below the threshold<br>
	 * Original signature : <code>void cvThreshHist(CvHistogram*, double)</code><br>
	 * <i>native declaration : cv.h:838</i>
	 */
	void cvThreshHist(fr.prima.jna.opencv.cxtypes.CvHistogram hist, double threshold);
	/**
	 * Compares two histogram<br>
	 * Original signature : <code>double cvCompareHist(const CvHistogram*, const CvHistogram*, int)</code><br>
	 * <i>native declaration : cv.h:846</i>
	 */
	double cvCompareHist(fr.prima.jna.opencv.cxtypes.CvHistogram hist1, fr.prima.jna.opencv.cxtypes.CvHistogram hist2, int method);
	/**
	 * Copies one histogram to another. Destination histogram is created if<br>
	 * the destination pointer is NULL<br>
	 * Original signature : <code>void cvCopyHist(const CvHistogram*, CvHistogram**)</code><br>
	 * <i>native declaration : cv.h:852</i><br>
	 * @deprecated use the safer method {@link #cvCopyHist(fr.prima.jna.opencv.cxtypes.CvHistogram, fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference[])} instead
	 */
	@java.lang.Deprecated
	void cvCopyHist(fr.prima.jna.opencv.cxtypes.CvHistogram src, com.sun.jna.ptr.PointerByReference dst);
	/**
	 * Copies one histogram to another. Destination histogram is created if<br>
	 * the destination pointer is NULL<br>
	 * Original signature : <code>void cvCopyHist(const CvHistogram*, CvHistogram**)</code><br>
	 * <i>native declaration : cv.h:852</i>
	 */
	void cvCopyHist(fr.prima.jna.opencv.cxtypes.CvHistogram src, fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference dst[]);
	/**
	 * Calculates bayesian probabilistic histograms<br>
	 * (each or src and dst is an array of <number> histograms<br>
	 * Original signature : <code>void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)</code><br>
	 * <i>native declaration : cv.h:857</i><br>
	 * @deprecated use the safer method {@link #cvCalcBayesianProb(fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference[], int, fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference[])} instead
	 */
	@java.lang.Deprecated
	void cvCalcBayesianProb(com.sun.jna.ptr.PointerByReference src, int number, com.sun.jna.ptr.PointerByReference dst);
	/**
	 * Calculates bayesian probabilistic histograms<br>
	 * (each or src and dst is an array of <number> histograms<br>
	 * Original signature : <code>void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)</code><br>
	 * <i>native declaration : cv.h:857</i>
	 */
	void cvCalcBayesianProb(fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference src[], int number, fr.prima.jna.opencv.cxtypes.CvHistogram.ByReference dst[]);
	/**
	 * Calculates array histogram<br>
	 * Original signature : <code>void cvCalcArrHist(CvArr**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:861</i>
	 */
	void cvCalcArrHist(com.sun.jna.ptr.PointerByReference arr, fr.prima.jna.opencv.cxtypes.CvHistogram hist, int accumulate, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvCalcHist(IplImage**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:865</i><br>
	 * @deprecated use the safer method {@link #cvCalcHist(fr.prima.jna.opencv.cxtypes.IplImage.ByReference[], fr.prima.jna.opencv.cxtypes.CvHistogram, int, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr)} instead
	 */
	@java.lang.Deprecated
	void cvCalcHist(com.sun.jna.ptr.PointerByReference image, fr.prima.jna.opencv.cxtypes.CvHistogram hist, int accumulate, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvCalcHist(IplImage**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : cv.h:865</i>
	 */
	void cvCalcHist(fr.prima.jna.opencv.cxtypes.IplImage.ByReference image[], fr.prima.jna.opencv.cxtypes.CvHistogram hist, int accumulate, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Calculates back project<br>
	 * Original signature : <code>void cvCalcArrBackProject(CvArr**, CvArr*, const CvHistogram*)</code><br>
	 * <i>native declaration : cv.h:873</i>
	 */
	void cvCalcArrBackProject(com.sun.jna.ptr.PointerByReference image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvHistogram hist);
	/**
	 * Does some sort of template matching but compares histograms of<br>
	 * template and each window location<br>
	 * Original signature : <code>void cvCalcArrBackProjectPatch(CvArr**, CvArr*, CvSize, CvHistogram*, int, double)</code><br>
	 * <i>native declaration : cv.h:880</i>
	 */
	void cvCalcArrBackProjectPatch(com.sun.jna.ptr.PointerByReference image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvSize.ByValue range, fr.prima.jna.opencv.cxtypes.CvHistogram hist, int method, double factor);
	/**
	 * calculates probabilistic density (divides one histogram by another)<br>
	 * Original signature : <code>void cvCalcProbDensity(const CvHistogram*, const CvHistogram*, CvHistogram*, double)</code><br>
	 * <i>native declaration : cv.h:888</i>
	 */
	void cvCalcProbDensity(fr.prima.jna.opencv.cxtypes.CvHistogram hist1, fr.prima.jna.opencv.cxtypes.CvHistogram hist2, fr.prima.jna.opencv.cxtypes.CvHistogram dst_hist, double scale);
	/**
	 * equalizes histogram of 8-bit single-channel image<br>
	 * Original signature : <code>void cvEqualizeHist(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:892</i>
	 */
	void cvEqualizeHist(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst);
	/**
	 * Updates active contour in order to minimize its cummulative<br>
	 * (internal and external) energy.<br>
	 * Original signature : <code>void cvSnakeImage(const IplImage*, CvPoint*, int, float*, float*, float*, int, CvSize, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv.h:899</i><br>
	 * @deprecated use the safer methods {@link #cvSnakeImage(fr.prima.jna.opencv.cxtypes.IplImage, fr.prima.jna.opencv.cxtypes.CvPoint, int, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, int, fr.prima.jna.opencv.cxtypes.CvSize.ByValue, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue, int)} and {@link #cvSnakeImage(fr.prima.jna.opencv.cxtypes.IplImage, fr.prima.jna.opencv.cxtypes.CvPoint, int, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.FloatByReference, int, fr.prima.jna.opencv.cxtypes.CvSize.ByValue, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue, int)} instead
	 */
	@java.lang.Deprecated
	void cvSnakeImage(fr.prima.jna.opencv.cxtypes.IplImage image, fr.prima.jna.opencv.cxtypes.CvPoint points, int length, com.sun.jna.ptr.FloatByReference alpha, com.sun.jna.ptr.FloatByReference beta, com.sun.jna.ptr.FloatByReference gamma, int coeff_usage, fr.prima.jna.opencv.cxtypes.CvSize.ByValue win, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria, int calc_gradient);
	/**
	 * Updates active contour in order to minimize its cummulative<br>
	 * (internal and external) energy.<br>
	 * Original signature : <code>void cvSnakeImage(const IplImage*, CvPoint*, int, float*, float*, float*, int, CvSize, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv.h:899</i>
	 */
	void cvSnakeImage(fr.prima.jna.opencv.cxtypes.IplImage image, fr.prima.jna.opencv.cxtypes.CvPoint points, int length, java.nio.FloatBuffer alpha, java.nio.FloatBuffer beta, java.nio.FloatBuffer gamma, int coeff_usage, fr.prima.jna.opencv.cxtypes.CvSize.ByValue win, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria, int calc_gradient);
	/**
	 * Calculates the cooficients of the homography matrix<br>
	 * Original signature : <code>void cvCalcImageHomography(float*, CvPoint3D32f*, float*, float*)</code><br>
	 * <i>native declaration : cv.h:906</i><br>
	 * @deprecated use the safer methods {@link #cvCalcImageHomography(java.nio.FloatBuffer, fr.prima.jna.opencv.cxtypes.CvPoint3D32f, java.nio.FloatBuffer, java.nio.FloatBuffer)} and {@link #cvCalcImageHomography(com.sun.jna.ptr.FloatByReference, fr.prima.jna.opencv.cxtypes.CvPoint3D32f, com.sun.jna.ptr.FloatByReference, com.sun.jna.ptr.FloatByReference)} instead
	 */
	@java.lang.Deprecated
	void cvCalcImageHomography(com.sun.jna.ptr.FloatByReference line, fr.prima.jna.opencv.cxtypes.CvPoint3D32f center, com.sun.jna.ptr.FloatByReference intrinsic, com.sun.jna.ptr.FloatByReference homography);
	/**
	 * Calculates the cooficients of the homography matrix<br>
	 * Original signature : <code>void cvCalcImageHomography(float*, CvPoint3D32f*, float*, float*)</code><br>
	 * <i>native declaration : cv.h:906</i>
	 */
	void cvCalcImageHomography(java.nio.FloatBuffer line, fr.prima.jna.opencv.cxtypes.CvPoint3D32f center, java.nio.FloatBuffer intrinsic, java.nio.FloatBuffer homography);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:914</i><br>
	 * @deprecated use the safer methods {@link #cvDistTransform(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, int, int, float[], fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr)} and {@link #cvDistTransform(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, int, int, com.sun.jna.ptr.FloatByReference, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr)} instead
	 */
	@java.lang.Deprecated
	void cvDistTransform(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int distance_type, int mask_size, com.sun.jna.ptr.FloatByReference mask, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr labels);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:914</i>
	 */
	void cvDistTransform(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, int distance_type, int mask_size, float mask[], fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr labels);
	/**
	 * Applies fixed-level threshold to grayscale image.<br>
	 * This is a basic operation applied before retrieving contours<br>
	 * Original signature : <code>void cvThreshold(const CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : cv.h:933</i>
	 */
	void cvThreshold(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, double threshold, double max_value, int threshold_type);
	/**
	 * Applies adaptive threshold to grayscale image.<br>
	 * The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and<br>
	 * CV_ADAPTIVE_THRESH_GAUSSIAN_C are:<br>
	 * neighborhood size (3, 5, 7 etc.),<br>
	 * and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...)<br>
	 * Original signature : <code>void cvAdaptiveThreshold(const CvArr*, CvArr*, double, int, int, int, double)</code><br>
	 * <i>native declaration : cv.h:945</i>
	 */
	void cvAdaptiveThreshold(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1);
	/**
	 * Fills the connected component until the color difference gets large enough<br>
	 * Original signature : <code>void cvFloodFill(CvArr*, CvPoint, CvScalar, CvScalar, CvScalar, CvConnectedComp*, int, CvArr*)</code><br>
	 * <i>native declaration : cv.h:955</i>
	 */
	void cvFloodFill(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue seed_point, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue new_val, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue lo_diff, fr.prima.jna.opencv.cxtypes.CvScalar.ByValue up_diff, fr.prima.jna.opencv.cvtypes.CvConnectedComp comp, int flags, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask);
	/**
	 * Runs canny edge detector<br>
	 * Original signature : <code>void cvCanny(const CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : cv.h:969</i>
	 */
	void cvCanny(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr edges, double threshold1, double threshold2, int aperture_size);
	/**
	 * Calculates constraint image for corner detection<br>
	 * Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.<br>
	 * Applying threshold to the result gives coordinates of corners<br>
	 * Original signature : <code>void cvPreCornerDetect(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv.h:975</i>
	 */
	void cvPreCornerDetect(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr corners, int aperture_size);
	/**
	 * Calculates eigen values and vectors of 2x2<br>
	 * gradient covariation matrix at every image pixel<br>
	 * Original signature : <code>void cvCornerEigenValsAndVecs(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cv.h:980</i>
	 */
	void cvCornerEigenValsAndVecs(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr eigenvv, int block_size, int aperture_size);
	/**
	 * Calculates minimal eigenvalue for 2x2 gradient covariation matrix at<br>
	 * every image pixel<br>
	 * Original signature : <code>void cvCornerMinEigenVal(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cv.h:985</i>
	 */
	void cvCornerMinEigenVal(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr eigenval, int block_size, int aperture_size);
	/**
	 * Harris corner detector:<br>
	 * Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel<br>
	 * Original signature : <code>void cvCornerHarris(const CvArr*, CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cv.h:990</i>
	 */
	void cvCornerHarris(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr harris_responce, int block_size, int aperture_size, double k);
	/**
	 * Adjust corner position using some sort of gradient search<br>
	 * Original signature : <code>void cvFindCornerSubPix(const CvArr*, CvPoint2D32f*, int, CvSize, CvSize, CvTermCriteria)</code><br>
	 * <i>native declaration : cv.h:995</i>
	 */
	void cvFindCornerSubPix(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvPoint2D32f corners, int count, fr.prima.jna.opencv.cxtypes.CvSize.ByValue win, fr.prima.jna.opencv.cxtypes.CvSize.ByValue zero_zone, fr.prima.jna.opencv.cxtypes.CvTermCriteria.ByValue criteria);
	/**
	 * Finds a sparse set of points within the selected region<br>
	 * that seem to be easy to track<br>
	 * Original signature : <code>void cvGoodFeaturesToTrack(const CvArr*, CvArr*, CvArr*, CvPoint2D32f*, int*, double, double, const CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cv.h:1001</i><br>
	 * @deprecated use the safer methods {@link #cvGoodFeaturesToTrack(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, java.nio.IntBuffer, double, double, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, int, int, double)} and {@link #cvGoodFeaturesToTrack(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, com.sun.jna.ptr.IntByReference, double, double, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, int, int, double)} instead
	 */
	@java.lang.Deprecated
	void cvGoodFeaturesToTrack(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr eig_image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr temp_image, fr.prima.jna.opencv.cxtypes.CvPoint2D32f corners, com.sun.jna.ptr.IntByReference corner_count, double quality_level, double min_distance, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask, int block_size, int use_harris, double k);
	/**
	 * Finds a sparse set of points within the selected region<br>
	 * that seem to be easy to track<br>
	 * Original signature : <code>void cvGoodFeaturesToTrack(const CvArr*, CvArr*, CvArr*, CvPoint2D32f*, int*, double, double, const CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cv.h:1001</i>
	 */
	void cvGoodFeaturesToTrack(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr eig_image, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr temp_image, fr.prima.jna.opencv.cxtypes.CvPoint2D32f corners, java.nio.IntBuffer corner_count, double quality_level, double min_distance, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mask, int block_size, int use_harris, double k);
	/**
	 * Finds lines on binary image using one of several methods.<br>
	 * line_storage is either memory storage or 1 x <max number of lines> CvMat, its<br>
	 * number of columns is changed by the function.<br>
	 * method is one of CV_HOUGH_*;<br>
	 * rho, theta and threshold are used for each of those methods;<br>
	 * param1 ~ line length, param2 ~ line gap - for probabilistic,<br>
	 * param1 ~ srn, param2 ~ stn - for multi-scale<br>
	 * Original signature : <code>CvSeq* cvHoughLines2(CvArr*, void*, int, double, double, int, double, double)</code><br>
	 * <i>native declaration : cv.h:1022</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvHoughLines2(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, com.sun.jna.Pointer line_storage, int method, double rho, double theta, int threshold, double param1, double param2);
	/**
	 * Finds circles in the image<br>
	 * Original signature : <code>CvSeq* cvHoughCircles(CvArr*, void*, int, double, double, double, double, int, int)</code><br>
	 * <i>native declaration : cv.h:1027</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvHoughCircles(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, com.sun.jna.Pointer circle_storage, int method, double dp, double min_dist, double param1, double param2, int min_radius, int max_radius);
	/**
	 * Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)<br>
	 * Original signature : <code>void cvFitLine(const CvArr*, int, double, double, double, float*)</code><br>
	 * <i>native declaration : cv.h:1035</i><br>
	 * @deprecated use the safer methods {@link #cvFitLine(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, int, double, double, double, java.nio.FloatBuffer)} and {@link #cvFitLine(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr, int, double, double, double, com.sun.jna.ptr.FloatByReference)} instead
	 */
	@java.lang.Deprecated
	void cvFitLine(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points, int dist_type, double param, double reps, double aeps, com.sun.jna.ptr.FloatByReference line);
	/**
	 * Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)<br>
	 * Original signature : <code>void cvFitLine(const CvArr*, int, double, double, double, float*)</code><br>
	 * <i>native declaration : cv.h:1035</i>
	 */
	void cvFitLine(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr points, int dist_type, double param, double reps, double aeps, java.nio.FloatBuffer line);
	/**
	 * Loads haar classifier cascade from a directory.<br>
	 * It is obsolete: convert your cascade to xml and use cvLoad instead<br>
	 * Original signature : <code>CvHaarClassifierCascade* cvLoadHaarClassifierCascade(const char*, CvSize)</code><br>
	 * <i>native declaration : cv.h:1044</i><br>
	 * @deprecated use the safer methods {@link #cvLoadHaarClassifierCascade(java.lang.String, fr.prima.jna.opencv.cxtypes.CvSize.ByValue)} and {@link #cvLoadHaarClassifierCascade(com.sun.jna.Pointer, fr.prima.jna.opencv.cxtypes.CvSize.ByValue)} instead
	 */
	@java.lang.Deprecated
	fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade cvLoadHaarClassifierCascade(com.sun.jna.Pointer directory, fr.prima.jna.opencv.cxtypes.CvSize.ByValue orig_window_size);
	/**
	 * Loads haar classifier cascade from a directory.<br>
	 * It is obsolete: convert your cascade to xml and use cvLoad instead<br>
	 * Original signature : <code>CvHaarClassifierCascade* cvLoadHaarClassifierCascade(const char*, CvSize)</code><br>
	 * <i>native declaration : cv.h:1044</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade cvLoadHaarClassifierCascade(java.lang.String directory, fr.prima.jna.opencv.cxtypes.CvSize.ByValue orig_window_size);
	/**
	 * Original signature : <code>void cvReleaseHaarClassifierCascade(CvHaarClassifierCascade**)</code><br>
	 * <i>native declaration : cv.h:1047</i><br>
	 * @deprecated use the safer method {@link #cvReleaseHaarClassifierCascade(fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade[])} instead
	 */
	@java.lang.Deprecated
	void cvReleaseHaarClassifierCascade(com.sun.jna.ptr.PointerByReference cascade);
	/**
	 * Original signature : <code>void cvReleaseHaarClassifierCascade(CvHaarClassifierCascade**)</code><br>
	 * <i>native declaration : cv.h:1047</i>
	 */
	void cvReleaseHaarClassifierCascade(fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade cascade[]);
	/**
	 * Original signature : <code>CvSeq* cvHaarDetectObjects(const CvArr*, CvHaarClassifierCascade*, CvMemStorage*, double, int, int, CvSize)</code><br>
	 * <i>native declaration : cv.h:1052</i>
	 */
	fr.prima.jna.opencv.cxtypes.CvSeq cvHaarDetectObjects(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade cascade, fr.prima.jna.opencv.cxtypes.CvMemStorage storage, double scale_factor, int min_neighbors, int flags, fr.prima.jna.opencv.cxtypes.CvSize.ByValue min_size);
	/**
	 * sets images for haar classifier cascade<br>
	 * Original signature : <code>void cvSetImagesForHaarClassifierCascade(CvHaarClassifierCascade*, const CvArr*, const CvArr*, const CvArr*, double)</code><br>
	 * <i>native declaration : cv.h:1059</i>
	 */
	void cvSetImagesForHaarClassifierCascade(fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade cascade, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr sum, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr sqsum, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr tilted_sum, double scale);
	/**
	 * runs the cascade on the specified window<br>
	 * Original signature : <code>int cvRunHaarClassifierCascade(CvHaarClassifierCascade*, CvPoint, int)</code><br>
	 * <i>native declaration : cv.h:1064</i>
	 */
	int cvRunHaarClassifierCascade(fr.prima.jna.opencv.cv.CvLibrary.CvHaarClassifierCascade cascade, fr.prima.jna.opencv.cxtypes.CvPoint.ByValue pt, int start_stage);
	/**
	 * transforms the input image to compensate lens distortion<br>
	 * Original signature : <code>void cvUndistort2(const CvArr*, CvArr*, const CvMat*, const CvMat*)</code><br>
	 * <i>native declaration : cv.h:1072</i>
	 */
	void cvUndistort2(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr src, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr dst, fr.prima.jna.opencv.cxtypes.CvMat intrinsic_matrix, fr.prima.jna.opencv.cxtypes.CvMat distortion_coeffs);
	/**
	 * computes transformation map from intrinsic camera parameters<br>
	 * that can used by cvRemap<br>
	 * Original signature : <code>void cvInitUndistortMap(const CvMat*, const CvMat*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv.h:1078</i>
	 */
	void cvInitUndistortMap(fr.prima.jna.opencv.cxtypes.CvMat intrinsic_matrix, fr.prima.jna.opencv.cxtypes.CvMat distortion_coeffs, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mapx, fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr mapy);
	/**
	 * converts rotation vector to rotation matrix or vice versa<br>
	 * Original signature : <code>int cvRodrigues2(const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1083</i>
	 */
	int cvRodrigues2(fr.prima.jna.opencv.cxtypes.CvMat src, fr.prima.jna.opencv.cxtypes.CvMat dst, fr.prima.jna.opencv.cxtypes.CvMat jacobian);
	/**
	 * finds perspective transformation between the object plane and image (view) plane<br>
	 * Original signature : <code>void cvFindHomography(const CvMat*, const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1087</i>
	 */
	void cvFindHomography(fr.prima.jna.opencv.cxtypes.CvMat src_points, fr.prima.jna.opencv.cxtypes.CvMat dst_points, fr.prima.jna.opencv.cxtypes.CvMat homography);
	/**
	 * projects object points to the view plane using<br>
	 * the specified extrinsic and intrinsic camera parameters<br>
	 * Original signature : <code>void cvProjectPoints2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1093</i>
	 */
	void cvProjectPoints2(fr.prima.jna.opencv.cxtypes.CvMat object_points, fr.prima.jna.opencv.cxtypes.CvMat rotation_vector, fr.prima.jna.opencv.cxtypes.CvMat translation_vector, fr.prima.jna.opencv.cxtypes.CvMat intrinsic_matrix, fr.prima.jna.opencv.cxtypes.CvMat distortion_coeffs, fr.prima.jna.opencv.cxtypes.CvMat image_points, fr.prima.jna.opencv.cxtypes.CvMat dpdrot, fr.prima.jna.opencv.cxtypes.CvMat dpdt, fr.prima.jna.opencv.cxtypes.CvMat dpdf, fr.prima.jna.opencv.cxtypes.CvMat dpdc, fr.prima.jna.opencv.cxtypes.CvMat dpddist);
	/**
	 * finds extrinsic camera parameters from<br>
	 * a few known corresponding point pairs and intrinsic parameters<br>
	 * Original signature : <code>void cvFindExtrinsicCameraParams2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1102</i>
	 */
	void cvFindExtrinsicCameraParams2(fr.prima.jna.opencv.cxtypes.CvMat object_points, fr.prima.jna.opencv.cxtypes.CvMat image_points, fr.prima.jna.opencv.cxtypes.CvMat intrinsic_matrix, fr.prima.jna.opencv.cxtypes.CvMat distortion_coeffs, fr.prima.jna.opencv.cxtypes.CvMat rotation_vector, fr.prima.jna.opencv.cxtypes.CvMat translation_vector);
	/**
	 * finds intrinsic and extrinsic camera parameters<br>
	 * from a few views of known calibration pattern<br>
	 * Original signature : <code>void cvCalibrateCamera2(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, int)</code><br>
	 * <i>native declaration : cv.h:1116</i>
	 */
	void cvCalibrateCamera2(fr.prima.jna.opencv.cxtypes.CvMat object_points, fr.prima.jna.opencv.cxtypes.CvMat image_points, fr.prima.jna.opencv.cxtypes.CvMat point_counts, fr.prima.jna.opencv.cxtypes.CvSize.ByValue image_size, fr.prima.jna.opencv.cxtypes.CvMat intrinsic_matrix, fr.prima.jna.opencv.cxtypes.CvMat distortion_coeffs, fr.prima.jna.opencv.cxtypes.CvMat rotation_vectors, fr.prima.jna.opencv.cxtypes.CvMat translation_vectors, int flags);
	/**
	 * Detects corners on a chessboard calibration pattern<br>
	 * Original signature : <code>int cvFindChessboardCorners(const void*, CvSize, CvPoint2D32f*, int*, int)</code><br>
	 * <i>native declaration : cv.h:1131</i><br>
	 * @deprecated use the safer methods {@link #cvFindChessboardCorners(com.sun.jna.Pointer, fr.prima.jna.opencv.cxtypes.CvSize.ByValue, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, java.nio.IntBuffer, int)} and {@link #cvFindChessboardCorners(com.sun.jna.Pointer, fr.prima.jna.opencv.cxtypes.CvSize.ByValue, fr.prima.jna.opencv.cxtypes.CvPoint2D32f, com.sun.jna.ptr.IntByReference, int)} instead
	 */
	@java.lang.Deprecated
	int cvFindChessboardCorners(com.sun.jna.Pointer image, fr.prima.jna.opencv.cxtypes.CvSize.ByValue pattern_size, fr.prima.jna.opencv.cxtypes.CvPoint2D32f corners, com.sun.jna.ptr.IntByReference corner_count, int flags);
	/**
	 * Detects corners on a chessboard calibration pattern<br>
	 * Original signature : <code>int cvFindChessboardCorners(const void*, CvSize, CvPoint2D32f*, int*, int)</code><br>
	 * <i>native declaration : cv.h:1131</i>
	 */
	int cvFindChessboardCorners(com.sun.jna.Pointer image, fr.prima.jna.opencv.cxtypes.CvSize.ByValue pattern_size, fr.prima.jna.opencv.cxtypes.CvPoint2D32f corners, java.nio.IntBuffer corner_count, int flags);
	/**
	 * Draws individual chessboard corners or the whole chessboard detected<br>
	 * Original signature : <code>void cvDrawChessboardCorners(CvArr*, CvSize, CvPoint2D32f*, int, int)</code><br>
	 * <i>native declaration : cv.h:1137</i>
	 */
	void cvDrawChessboardCorners(fr.prima.jna.opencv.highgui.HighguiLibrary.CvArr image, fr.prima.jna.opencv.cxtypes.CvSize.ByValue pattern_size, fr.prima.jna.opencv.cxtypes.CvPoint2D32f corners, int count, int pattern_was_found);
	/**
	 * Allocates and initializes CvPOSITObject structure before doing cvPOSIT<br>
	 * Original signature : <code>CvPOSITObject* cvCreatePOSITObject(CvPoint3D32f*, int)</code><br>
	 * <i>native declaration : cv.h:1144</i>
	 */
	fr.prima.jna.opencv.cv.CvLibrary.CvPOSITObject cvCreatePOSITObject(fr.prima.jna.opencv.cxtypes.CvPoint3D32f points, int point_count);
	/**
	 * <i>native declaration : cv.h:1149</i><br>
	 * Conversion Error : CvMatr32f
	 */
	/**
	 * Releases CvPOSITObject structure<br>
	 * Original signature : <code>void cvReleasePOSITObject(CvPOSITObject**)</code><br>
	 * <i>native declaration : cv.h:1154</i><br>
	 * @deprecated use the safer method {@link #cvReleasePOSITObject(fr.prima.jna.opencv.cv.CvLibrary.CvPOSITObject[])} instead
	 */
	@java.lang.Deprecated
	void cvReleasePOSITObject(com.sun.jna.ptr.PointerByReference posit_object);
	/**
	 * Releases CvPOSITObject structure<br>
	 * Original signature : <code>void cvReleasePOSITObject(CvPOSITObject**)</code><br>
	 * <i>native declaration : cv.h:1154</i>
	 */
	void cvReleasePOSITObject(fr.prima.jna.opencv.cv.CvLibrary.CvPOSITObject posit_object[]);
	/**
	 * Original signature : <code>void cvConvertPointsHomogenious(const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1161</i>
	 */
	void cvConvertPointsHomogenious(fr.prima.jna.opencv.cxtypes.CvMat src, fr.prima.jna.opencv.cxtypes.CvMat dst);
	/**
	 * Original signature : <code>int cvFindFundamentalMat(const CvMat*, const CvMat*, CvMat*, int, double, double, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1170</i>
	 */
	int cvFindFundamentalMat(fr.prima.jna.opencv.cxtypes.CvMat points1, fr.prima.jna.opencv.cxtypes.CvMat points2, fr.prima.jna.opencv.cxtypes.CvMat fundamental_matrix, int method, double param1, double param2, fr.prima.jna.opencv.cxtypes.CvMat status);
	/**
	 * For each input point on one of images<br>
	 * computes parameters of the corresponding<br>
	 * epipolar line on the other image<br>
	 * Original signature : <code>void cvComputeCorrespondEpilines(const CvMat*, int, const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv.h:1179</i>
	 */
	void cvComputeCorrespondEpilines(fr.prima.jna.opencv.cxtypes.CvMat points, int which_image, fr.prima.jna.opencv.cxtypes.CvMat fundamental_matrix, fr.prima.jna.opencv.cxtypes.CvMat correspondent_lines);
	/// Pointer to unknown (opaque) type
	public static class CvConDensation extends com.sun.jna.PointerType {
		public CvConDensation(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvConDensation() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvContourScanner extends com.sun.jna.PointerType {
		public CvContourScanner(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvContourScanner() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvHaarClassifierCascade extends com.sun.jna.PointerType {
		public CvHaarClassifierCascade(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvHaarClassifierCascade() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvPOSITObject extends com.sun.jna.PointerType {
		public CvPOSITObject(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvPOSITObject() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvSubdiv2D extends com.sun.jna.PointerType {
		public CvSubdiv2D(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvSubdiv2D() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvSubdiv2DPoint extends com.sun.jna.PointerType {
		public CvSubdiv2DPoint(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvSubdiv2DPoint() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvContourTree extends com.sun.jna.PointerType {
		public CvContourTree(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvContourTree() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvKalman extends com.sun.jna.PointerType {
		public CvKalman(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvKalman() {
			super();
		}
	}
}
