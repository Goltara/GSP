=============================
=== TODO from GSPExamples ===
=============================
C/CPP:
check framework.h synchronicity

CPP:
check in Div::input that the local vars are still needed.
namespace the example

java:
check README instructions (how to compile, framework jar path)

CPP:
add examples using FIELD_WITH_SETTER and STRING_FIELD_WITH_SETTER

more:
add examples with passive modules (reusing modules in a plain program)



==============================
=== TODO from GSPFramework ===
==============================

* a "-?" "--help" option that explores the pipeline and reports the
   variables, etc

* 

* fix in GSPBaseUtils the For module with 0 as a period

* handle the fact that string get garbage collected (C++ should do a copy on receive or at least we can try to prevent gc for parameters (not that simple) until the pipeline is gc'ed)

v
* better feedback on setter (c++) not found

* same better feedback for invocationtargetexception when binding
   wrongly connectors (java included)

* better feedback when a java class has multiple methods (event
   receivers) with the same name

* base utils
** timer/clock/thread (all the same thing) : done?
** thread fork/join
** merger/extractor (parameter list ...) (option: emit at each change or emit when all changed at least once or emit when all changed once (block others before that))

* omiscid utils?

* example pure-java-5 should not start if parameters are missing!

* handle cpp class inheritance if we can get the info somewhere

* CPP: namespaces

* CPP: easy setters (orthogonal to gsp) : done

* unallocated module when stopping pipeline

* idea: replace a#b#c by something asymetric (e.g. a(b)c or a[b]c or a]b[c or a)b(c (no <> as in xml)) ...
    <c chain="tick - intInput#half# - half - #th#string - str#dup#str - log"/>        current

    <c chain="tick - intInput(half - half - th)string - str(dup)str - log"/>

    <c chain="tick - intInput)half - half - th(string - str)dup(str - log"/>

    <c chain="tick - intInput[half - half - th]string - str[dup]str - log"/>

    <c chain="tick - intInput]half - half - th[string - str]dup[str - log"/>

    <c chain="tick - intInput(half) - half - (th)string - str(dup)str - log"/>

    <c chain="tick - intInput)half( - half - )th(string - str)dup(str - log"/>

    <c chain="tick - intInput[half] - half - [th]string - str[dup]str - log"/>

    <c chain="tick - intInput]half[ - half - ]th[string - str]dup[str - log"/>



* could pass a more opaque structure as Pointer (when invoking a java
   method with a C/C++ pointer)
=> it would also minize the requirements to build some java module (do
   not require jna if the op on pointers are usual)
=> could also put some custom metatype info in it (to pass it back to C)
: done?

* handle possibility for a module to know if it has some "clients" on an output
* metamodules in .xml (a module as an assembly of modules) (could be a special type of modules like C modules with a namespace c: ==> e.g. xml:path/to/metatrucs.xml/Div)

* OPT: add a define that generate a human oriented version of the struct (use e.g. ___NL___ for new lines, then replace them all by a real new line in the helper script)


java -Djava.library.path=. -cp  ../GSPExample/java:../GSPFramework/target/dependency/*:../GSPFramework/target/gsp-framework-1.1-SNAPSHOT.jar:java fr.prima.gsp.Launcher ../GSPExample/pipeline-cpp-3-with-param.xml p=20

